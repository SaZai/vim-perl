<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Moose::Meta::TypeConstraint::Union</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Moose::Meta::TypeConstraint::Union::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Moose::Meta::TypeConstraint::Union::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;
<span class="synStatement">use </span>metaclass;

<span class="synStatement">use </span>Moose::Meta::TypeCoercion::Union;

<span class="synStatement">use </span>List::MoreUtils <span class="synString">qw(all)</span>;
<span class="synStatement">use </span>List::Util <span class="synString">qw(first)</span>;

<span class="synStatement">use base</span> <span class="synString">'Moose::Meta::TypeConstraint'</span>;

__PACKAGE__<span class="synIdentifier">-&gt;meta-&gt;add_attribute</span>(<span class="synString">'type_constraints'</span> =&gt; (
    <span class="synString">accessor</span>  =&gt; <span class="synString">'type_constraints'</span>,
    <span class="synString">default</span>   =&gt; <span class="synKeyword">sub </span>{ [] },
    Class::MOP::_definition_context(),
));

<span class="synKeyword">sub </span><span class="synFunction">new </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>, <span class="synIdentifier">%options</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synStatement">join</span> <span class="synString">'|'</span> =&gt; <span class="synStatement">sort</span> <span class="synStatement">{</span> <span class="synIdentifier">$a</span> <span class="synOperator">cmp</span> <span class="synIdentifier">$b</span> <span class="synStatement">}</span>
        <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$options{</span><span class="synString">type_constraints</span><span class="synIdentifier">}</span> <span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synIdentifier">$class-&gt;SUPER</span>::new(
        <span class="synString">name</span> =&gt; <span class="synIdentifier">$name</span>,
        <span class="synIdentifier">%options</span>,
    );

    <span class="synIdentifier">$self-&gt;_set_constraint</span>( <span class="synIdentifier">$self-&gt;_compiled_type_constraint</span> );

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
}

<span class="synComment"># </span><span class="synTodo">XXX</span><span class="synComment"> - this is a rather gross implementation of laziness for the benefit of</span>
<span class="synComment"># MX::Types. If we try to call -&gt;has_coercion on the objects during object</span>
<span class="synComment"># construction, this does not work when defining a recursive constraint with</span>
<span class="synComment"># MX::Types.</span>
<span class="synKeyword">sub </span><span class="synFunction">coercion </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">coercion</span><span class="synIdentifier">}</span> <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">coercion</span><span class="synIdentifier">}</span>;

    <span class="synComment"># Using any instead of grep here causes a weird error with some corner</span>
    <span class="synComment"># cases when MX::Types is in use. See RT #61001.</span>
    <span class="synConditional">if</span> ( <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;has_coercion</span> <span class="synStatement">}</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">coercion</span><span class="synIdentifier">}</span> = Moose::Meta::TypeCoercion::Union-&gt;new(
            <span class="synString">type_constraint</span> =&gt; <span class="synIdentifier">$self</span> );
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">coercion</span><span class="synIdentifier">}</span> = <span class="synOperator">undef</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">has_coercion </span>{
    <span class="synStatement">return</span> <span class="synOperator">defined</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]-&gt;coercion</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_actually_compile_type_constraint </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@constraints</span> = <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;

    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> <span class="synIdentifier">$value</span> = <span class="synStatement">shift</span>;
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synIdentifier">@constraints</span>) {
            <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$type-&gt;check</span>(<span class="synIdentifier">$value</span>);
        }
        <span class="synStatement">return</span> <span class="synOperator">undef</span>;
    };
}

<span class="synKeyword">sub </span><span class="synFunction">can_be_inlined </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># This was originally done with all() from List::MoreUtils, but that</span>
    <span class="synComment"># caused some sort of bizarro parsing failure under 5.10.</span>
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$tc</span> ( <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synNumber">0</span> <span class="synConditional">unless</span> <span class="synIdentifier">$tc-&gt;can_be_inlined</span>;
    }

    <span class="synStatement">return</span> <span class="synNumber">1</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_check </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$val</span>  = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synString">'('</span>
               . (
                  <span class="synStatement">join</span> <span class="synString">' || '</span>, <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synString">'('</span> . <span class="synIdentifier">$_-&gt;_inline_check</span>(<span class="synIdentifier">$val</span>) . <span class="synString">')'</span> <span class="synStatement">}</span>
                  <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>
                 )
           . <span class="synString">')'</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">inline_environment </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> { <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">%{</span> <span class="synIdentifier">$_-&gt;inline_environment</span> <span class="synIdentifier">}</span> <span class="synStatement">}</span>
            <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span> };
}

<span class="synKeyword">sub </span><span class="synFunction">equals </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$type_or_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$other</span> = Moose::Util::TypeConstraints::find_type_constraint(<span class="synIdentifier">$type_or_name</span>);

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$other-&gt;isa</span>(__PACKAGE__);

    <span class="synStatement">my</span> <span class="synIdentifier">@self_constraints</span>  = <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@other_constraints</span> = <span class="synIdentifier">@{</span> <span class="synIdentifier">$other-&gt;type_constraints</span> <span class="synIdentifier">}</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">@self_constraints</span> == <span class="synIdentifier">@other_constraints</span>;

    <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> presort type constraints for efficiency?</span>
<span class="synLabel">    constraint:</span> <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span> ( <span class="synIdentifier">@self_constraints</span> ) {
        <span class="synRepeat">for</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synNumber">0</span>; <span class="synIdentifier">$i</span> &lt; <span class="synIdentifier">@other_constraints</span>; <span class="synIdentifier">$i</span>++ ) {
            <span class="synConditional">if</span> ( <span class="synIdentifier">$constraint-&gt;equals</span>(<span class="synIdentifier">$other_constraints[$i]</span>) ) {
                <span class="synStatement">splice</span> <span class="synIdentifier">@other_constraints</span>, <span class="synIdentifier">$i</span>, <span class="synNumber">1</span>;
                <span class="synStatement">next</span> constraint;
            }
        }
    }

    <span class="synStatement">return</span> <span class="synIdentifier">@other_constraints</span> == <span class="synNumber">0</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">parent </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> (<span class="synIdentifier">$first</span>, <span class="synIdentifier">@rest</span>) = <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$parent</span> ( <span class="synIdentifier">$first-&gt;_collect_all_parents</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$parent</span> <span class="synConditional">if</span> all { <span class="synIdentifier">$_-&gt;is_a_type_of</span>(<span class="synIdentifier">$parent</span>) } <span class="synIdentifier">@rest</span>;
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">validate </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$value</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$message</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synIdentifier">@{$self-&gt;type_constraints}</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$err</span> = <span class="synIdentifier">$type-&gt;validate</span>(<span class="synIdentifier">$value</span>);
        <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$err</span>;
        <span class="synIdentifier">$message</span> .= (<span class="synIdentifier">$message</span> ? <span class="synString">' and '</span> : <span class="synString">''</span>) . <span class="synIdentifier">$err</span>
            <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$err</span>;
    }
    <span class="synStatement">return</span> (<span class="synIdentifier">$message</span> . <span class="synString">' in ('</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">')'</span>) ;
}

<span class="synKeyword">sub </span><span class="synFunction">find_type_for </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$value</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> first { <span class="synIdentifier">$_-&gt;check</span>(<span class="synIdentifier">$value</span>) } <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">is_a_type_of </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$type_name</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> all { <span class="synIdentifier">$_-&gt;is_a_type_of</span>(<span class="synIdentifier">$type_name</span>) } <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">is_subtype_of </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$type_name</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> all { <span class="synIdentifier">$_-&gt;is_subtype_of</span>(<span class="synIdentifier">$type_name</span>) } <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;type_constraints</span> <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">create_child_type </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%opts</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span>
        = Moose::Meta::TypeConstraint-&gt;new( <span class="synIdentifier">%opts</span>, <span class="synString">parent</span> =&gt; <span class="synIdentifier">$self</span> );

    <span class="synComment"># if we have a type constraint union, and no</span>
    <span class="synComment"># type check, this means we are just aliasing</span>
    <span class="synComment"># the union constraint, which means we need to</span>
    <span class="synComment"># handle this differently.</span>
    <span class="synComment"># - SL</span>
    <span class="synConditional">if</span> ( <span class="synOperator">not</span>( <span class="synOperator">defined</span> <span class="synIdentifier">$opts{</span><span class="synString">constraint</span><span class="synIdentifier">}</span> )
        &amp;&amp; <span class="synIdentifier">$self-&gt;has_coercion</span> ) {
        <span class="synIdentifier">$constraint-&gt;coercion</span>(
            Moose::Meta::TypeCoercion::Union-&gt;new(
                <span class="synString">type_constraint</span> =&gt; <span class="synIdentifier">$self</span>,
            )
        );
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
}

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: A union of Moose type constraints</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

Moose::Meta::TypeConstraint::Union - A union of Moose type constraints

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

version 2.1005

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

This metaclass represents a union of type constraints. A union takes
multiple type constraints, and is true if any one of its member
constraints is true.

<span class="synStatement">=head1</span><span class="synString"> INHERITANCE</span>

<span class="synIdentifier">C&lt;Moose::Meta::TypeConstraint::Union&gt;</span> is a subclass of
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span>.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Moose::Meta::TypeConstraint::Union-&gt;new(%options) &gt;&gt;</span>

This creates a new class type constraint based on the given
<span class="synIdentifier">C&lt;%options&gt;</span>.

It takes the same options as its parent. It also requires an
additional option, <span class="synIdentifier">C&lt;type_constraints&gt;</span>. This is an array reference
containing the <span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span> objects that are the
members of the union type. The <span class="synIdentifier">C&lt;name&gt;</span> option defaults to the names
all of these member types sorted and then joined by a pipe (|).

The constructor sets the implementation of the constraint so that is
simply calls <span class="synIdentifier">C&lt;check&gt;</span> on the newly created object.

Finally, the constructor also makes sure that the object's <span class="synIdentifier">C&lt;coercion&gt;</span>
attribute is a <span class="synIdentifier">L&lt;Moose::Meta::TypeCoercion::Union&gt;</span> object.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;type_constraints &gt;&gt;</span>

This returns the array reference of <span class="synIdentifier">C&lt;type_constraints&gt;</span> provided to
the constructor.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;parent &gt;&gt;</span>

This returns the nearest common ancestor of all the components of the union.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;check($value) &gt;&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;validate($value) &gt;&gt;</span>

These two methods simply call the relevant method on each of the
member type constraints in the union. If any type accepts the value,
the value is valid.

With <span class="synIdentifier">C&lt;validate&gt;</span> the error message returned includes all of the error
messages returned by the member type constraints.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;equals($type_name_or_object) &gt;&gt;</span>

A type is considered equal if it is also a union type, and the two
unions have the same member types.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;find_type_for($value) &gt;&gt;</span>

This returns the first member type constraint for which <span class="synIdentifier">C&lt;check($value)&gt;</span> is
true, allowing you to determine which of the Union's member type constraints
a given value matches.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;is_a_type_of($type_name_or_object) &gt;&gt;</span>

This returns true if all of the member type constraints return true
for the <span class="synIdentifier">C&lt;is_a_type_of&gt;</span> method.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;is_subtype_of &gt;&gt;</span>

This returns true if all of the member type constraints return true
for the <span class="synIdentifier">C&lt;is_a_subtype_of&gt;</span> method.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $constraint-&gt;create_child_type(%options) &gt;&gt;</span>

This returns a new <span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span> object with the type
as its parent.

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

See <span class="synIdentifier">L&lt;Moose/BUGS&gt;</span> for details on reporting bugs.

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

Moose is maintained by the Moose Cabal, along with the help of many contributors. See <span class="synIdentifier">L&lt;Moose/CABAL&gt;</span> and <span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span> for details.

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

This software is copyright (c) 2013 by Infinity Interactive, Inc..

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
