<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Class::MOP::Class</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span>Class::MOP::Instance;
<span class="synStatement">use </span>Class::MOP::Method::Wrapped;
<span class="synStatement">use </span>Class::MOP::Method::Accessor;
<span class="synStatement">use </span>Class::MOP::Method::Constructor;
<span class="synStatement">use </span>Class::MOP::MiniTrait;

<span class="synStatement">use </span>Carp         <span class="synString">'confess'</span>;
<span class="synStatement">use </span>Class::Load  <span class="synString">'is_class_loaded'</span>, <span class="synString">'load_class'</span>;
<span class="synStatement">use </span>Scalar::Util <span class="synString">'blessed'</span>, <span class="synString">'reftype'</span>, <span class="synString">'weaken'</span>;
<span class="synStatement">use </span>Sub::Name    <span class="synString">'subname'</span>;
<span class="synStatement">use </span>Try::Tiny;
<span class="synStatement">use </span>List::MoreUtils <span class="synString">'all'</span>;

<span class="synStatement">use base</span> <span class="synString">'Class::MOP::Module'</span>,
         <span class="synString">'Class::MOP::Mixin::HasAttributes'</span>,
         <span class="synString">'Class::MOP::Mixin::HasMethods'</span>;

<span class="synComment"># Creation</span>

<span class="synKeyword">sub </span><span class="synFunction">initialize </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$package_name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">@_</span> % <span class="synNumber">2</span> ) {
        <span class="synIdentifier">$package_name</span> = <span class="synStatement">shift</span>;
    } <span class="synConditional">else</span> {
        <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@_</span>;
        <span class="synIdentifier">$package_name</span> = <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    }

    (<span class="synIdentifier">$package_name</span> &amp;&amp; !<span class="synOperator">ref</span>(<span class="synIdentifier">$package_name</span>))
        || confess <span class="synString">&quot;You must pass a package name and it cannot be blessed&quot;</span>;

    <span class="synStatement">return</span> Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$package_name</span>)
        || <span class="synIdentifier">$class-&gt;_construct_class_instance</span>(<span class="synString">package</span> =&gt; <span class="synIdentifier">$package_name</span>, <span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">reinitialize </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">unshift</span> <span class="synIdentifier">@args</span>, <span class="synString">&quot;package&quot;</span> <span class="synConditional">if</span> <span class="synIdentifier">@args</span> % <span class="synNumber">2</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@args</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = blessed(<span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>)
        ? <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>
        : Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>);
    <span class="synIdentifier">$options{</span><span class="synString">weaken</span><span class="synIdentifier">}</span> = Class::MOP::metaclass_is_weak(<span class="synIdentifier">$old_metaclass-&gt;name</span>)
        <span class="synConditional">if</span> !<span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">weaken</span><span class="synIdentifier">}</span>
        &amp;&amp; blessed(<span class="synIdentifier">$old_metaclass</span>)
        &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synIdentifier">$old_metaclass-&gt;_remove_generated_metaobjects</span>
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span> &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$new_metaclass</span> = <span class="synIdentifier">$class-&gt;SUPER</span>::reinitialize(<span class="synIdentifier">%options</span>);
    <span class="synIdentifier">$new_metaclass-&gt;_restore_metaobjects_from</span>(<span class="synIdentifier">$old_metaclass</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span> &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$new_metaclass</span>;
}

<span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> (meta-circularity)</span>
<span class="synComment"># this is a special form of _construct_instance</span>
<span class="synComment"># (see below), which is used to construct class</span>
<span class="synComment"># meta-object instances for any Class::MOP::*</span>
<span class="synComment"># class. All other classes will use the more</span>
<span class="synComment"># normal &amp;construct_instance.</span>
<span class="synKeyword">sub </span><span class="synFunction">_construct_class_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>        = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$options</span>      = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};
    <span class="synStatement">my</span> <span class="synIdentifier">$package_name</span> = <span class="synIdentifier">$options-&gt;{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$package_name</span> &amp;&amp; <span class="synIdentifier">$package_name</span>)
        || confess <span class="synString">&quot;You must pass a package name&quot;</span>;
    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># return the metaclass if we have it cached,</span>
    <span class="synComment"># and it is still defined (it has not been</span>
    <span class="synComment"># reaped by DESTROY yet, which can happen</span>
    <span class="synComment"># annoyingly enough during global destruction)</span>

    <span class="synConditional">if</span> (<span class="synOperator">defined</span>(<span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$package_name</span>))) {
        <span class="synStatement">return</span> <span class="synIdentifier">$meta</span>;
    }

    <span class="synIdentifier">$class</span>
        = <span class="synOperator">ref</span> <span class="synIdentifier">$class</span>
        ? <span class="synIdentifier">$class-&gt;_real_ref_name</span>
        : <span class="synIdentifier">$class</span>;

    <span class="synComment"># now create the metaclass</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span>;
    <span class="synConditional">if</span> (<span class="synIdentifier">$class</span> <span class="synOperator">eq</span> <span class="synString">'Class::MOP::Class'</span>) {
        <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;_new</span>(<span class="synIdentifier">$options</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># it is safe to use meta here because</span>
        <span class="synComment"># class will always be a subclass of</span>
        <span class="synComment"># Class::MOP::Class, which defines meta</span>
        <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;meta-&gt;_construct_instance</span>(<span class="synIdentifier">$options</span>)
    }

    <span class="synComment"># and check the metaclass compatibility</span>
    <span class="synIdentifier">$meta-&gt;_check_metaclass_compatibility</span>();

    Class::MOP::store_metaclass_by_name(<span class="synIdentifier">$package_name</span>, <span class="synIdentifier">$meta</span>);

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to weaken any anon classes</span>
    <span class="synComment"># so that they can call DESTROY properly</span>
    Class::MOP::weaken_metaclass(<span class="synIdentifier">$package_name</span>) <span class="synConditional">if</span> <span class="synIdentifier">$options-&gt;{</span><span class="synString">weaken</span><span class="synIdentifier">}</span>;

    <span class="synIdentifier">$meta</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_real_ref_name </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to deal with the possibility of class immutability here,</span>
    <span class="synComment"># and then get the name of the class appropriately</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;is_immutable</span>
        ? <span class="synIdentifier">$self-&gt;_get_mutable_metaclass_name</span>()
        : <span class="synOperator">ref</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_new </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;new_object(<span class="synIdentifier">@_</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$class</span> <span class="synOperator">ne</span> __PACKAGE__;

    <span class="synStatement">my</span> <span class="synIdentifier">$options</span> = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};

    <span class="synStatement">return</span> <span class="synOperator">bless</span> {
        <span class="synComment"># inherited from Class::MOP::Package</span>
        <span class="synString">'package'</span> =&gt; <span class="synIdentifier">$options-&gt;{</span><span class="synString">package</span><span class="synIdentifier">}</span>,

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># since the following attributes will</span>
        <span class="synComment"># actually be loaded from the symbol</span>
        <span class="synComment"># table, and actually bypass the instance</span>
        <span class="synComment"># entirely, we can just leave these things</span>
        <span class="synComment"># listed here for reference, because they</span>
        <span class="synComment"># should not actually have a value associated</span>
        <span class="synComment"># with the slot.</span>
        <span class="synString">'namespace'</span> =&gt; \<span class="synOperator">undef</span>,
        <span class="synString">'methods'</span>   =&gt; {},

        <span class="synComment"># inherited from Class::MOP::Module</span>
        <span class="synString">'version'</span>   =&gt; \<span class="synOperator">undef</span>,
        <span class="synString">'authority'</span> =&gt; \<span class="synOperator">undef</span>,

        <span class="synComment"># defined in Class::MOP::Class</span>
        <span class="synString">'superclasses'</span> =&gt; \<span class="synOperator">undef</span>,

        <span class="synString">'attributes'</span> =&gt; {},
        <span class="synString">'attribute_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'attribute_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Attribute'</span> ),
        <span class="synString">'method_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'method_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Method'</span> ),
        <span class="synString">'wrapped_method_metaclass'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">'wrapped_method_metaclass'</span><span class="synIdentifier">}</span>
                || <span class="synString">'Class::MOP::Method::Wrapped'</span>
        ),
        <span class="synString">'instance_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'instance_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Instance'</span> ),
        <span class="synString">'immutable_trait'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">'immutable_trait'</span><span class="synIdentifier">}</span>
                || <span class="synString">'Class::MOP::Class::Immutable::Trait'</span>
        ),
        <span class="synString">'constructor_name'</span> =&gt; ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">constructor_name</span><span class="synIdentifier">}</span> || <span class="synString">'new'</span> ),
        <span class="synString">'constructor_class'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">constructor_class</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Method::Constructor'</span>
        ),
        <span class="synString">'destructor_class'</span> =&gt; <span class="synIdentifier">$options-&gt;{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span>,
    }, <span class="synIdentifier">$class</span>;
}

<span class="synComment">## Metaclass compatibility</span>
{
    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = (
        <span class="synString">attribute_metaclass</span>      =&gt; <span class="synString">'Class::MOP::Attribute'</span>,
        <span class="synString">method_metaclass</span>         =&gt; <span class="synString">'Class::MOP::Method'</span>,
        <span class="synString">wrapped_method_metaclass</span> =&gt; <span class="synString">'Class::MOP::Method::Wrapped'</span>,
        <span class="synString">instance_metaclass</span>       =&gt; <span class="synString">'Class::MOP::Instance'</span>,
        <span class="synString">constructor_class</span>        =&gt; <span class="synString">'Class::MOP::Method::Constructor'</span>,
        <span class="synString">destructor_class</span>         =&gt; <span class="synString">'Class::MOP::Method::Destructor'</span>,
    );

    <span class="synKeyword">sub </span><span class="synFunction">_base_metaclasses </span>{ <span class="synIdentifier">%base_metaclass</span> }
}

<span class="synKeyword">sub </span><span class="synFunction">_check_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@superclasses</span> = <span class="synIdentifier">$self-&gt;superclasses</span>
        <span class="synOperator">or</span> <span class="synStatement">return</span>;

    <span class="synIdentifier">$self-&gt;_fix_metaclass_incompatibility</span>(<span class="synIdentifier">@superclasses</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;

    <span class="synComment"># this is always okay ...</span>
    <span class="synStatement">return</span>
        <span class="synConditional">if</span> <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>) <span class="synOperator">eq</span> <span class="synString">'Class::MOP::Class'</span>
            &amp;&amp; all {
                <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$self-&gt;$_</span>;
                !<span class="synOperator">defined</span>(<span class="synIdentifier">$meta</span>) || <span class="synIdentifier">$meta</span> <span class="synOperator">eq</span> <span class="synIdentifier">$base_metaclass{$_}</span>;
        }
        <span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$superclass</span> (<span class="synIdentifier">@superclasses</span>) {
        <span class="synIdentifier">$self-&gt;_check_class_metaclass_compatibility</span>(<span class="synIdentifier">$superclass</span>);
    }

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span> ) {
        <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$self-&gt;$metaclass_type</span>;
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$superclass</span> (<span class="synIdentifier">@superclasses</span>) {
            <span class="synIdentifier">$self-&gt;_check_single_metaclass_compatibility</span>( <span class="synIdentifier">$metaclass_type</span>,
                <span class="synIdentifier">$superclass</span> );
        }
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_check_class_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_class_metaclass_is_compatible</span>(<span class="synIdentifier">$superclass_name</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>);

        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_type</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

        confess <span class="synString">&quot;The metaclass of &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot; (&quot;</span>
              . (<span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>)) . <span class="synString">&quot;)&quot;</span> .  <span class="synString">&quot; is not compatible with &quot;</span>
              . <span class="synString">&quot;the metaclass of its superclass, &quot;</span>
              . <span class="synIdentifier">$superclass_name</span> . <span class="synString">&quot; (&quot;</span> . (<span class="synIdentifier">$super_meta_type</span>) . <span class="synString">&quot;)&quot;</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_class_metaclass_is_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>)
        || <span class="synStatement">return</span> <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_name</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;_is_compatible_with</span>(<span class="synIdentifier">$super_meta_name</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_check_single_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_single_metaclass_is_compatible</span>(<span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>);
        <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type_name</span> = <span class="synIdentifier">$metaclass_type</span>;
        <span class="synIdentifier">$metaclass_type_name</span> =~ <span class="synStatement">s/</span><span class="synString">_</span><span class="synSpecial">(?:</span><span class="synString">meta</span><span class="synSpecial">)?</span><span class="synString">class$</span><span class="synStatement">//</span>;
        <span class="synIdentifier">$metaclass_type_name</span> =~ <span class="synStatement">s/</span><span class="synString">_</span><span class="synStatement">/</span><span class="synString"> </span><span class="synStatement">/g</span>;
        confess <span class="synString">&quot;The </span><span class="synIdentifier">$metaclass_type_name</span><span class="synString"> metaclass for &quot;</span>
              . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot; (&quot;</span> . (<span class="synIdentifier">$self-&gt;$metaclass_type</span>)
              . <span class="synString">&quot;)&quot;</span> . <span class="synString">&quot; is not compatible with the &quot;</span>
              . <span class="synString">&quot;</span><span class="synIdentifier">$metaclass_type_name</span><span class="synString"> metaclass of its &quot;</span>
              . <span class="synString">&quot;superclass, </span><span class="synIdentifier">$superclass_name</span><span class="synString"> (&quot;</span>
              . (<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>) . <span class="synString">&quot;)&quot;</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_single_metaclass_is_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>)
        || <span class="synStatement">return</span> <span class="synNumber">1</span>;

    <span class="synComment"># for instance, Moose::Meta::Class has a error_class attribute, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synIdentifier">$super_meta-&gt;can</span>(<span class="synIdentifier">$metaclass_type</span>);
    <span class="synComment"># for instance, Moose::Meta::Class has a destructor_class, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;
    <span class="synComment"># if metaclass is defined in superclass but not here, it's not compatible</span>
    <span class="synComment"># this is a really odd case</span>
    <span class="synStatement">return</span> <span class="synNumber">0</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$self-&gt;$metaclass_type</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;$metaclass_type-&gt;_is_compatible_with</span>(<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@supers</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$necessary</span> = <span class="synNumber">0</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
        <span class="synIdentifier">$necessary</span> = <span class="synNumber">1</span>
            <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_can_fix_metaclass_incompatibility</span>(<span class="synIdentifier">$super</span>);
    }
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$necessary</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
        <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_class_metaclass_is_compatible</span>(<span class="synIdentifier">$super-&gt;name</span>)) {
            <span class="synIdentifier">$self-&gt;_fix_class_metaclass_incompatibility</span>(<span class="synIdentifier">$super</span>);
        }
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>) {
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
            <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_single_metaclass_is_compatible</span>(<span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super-&gt;name</span>)) {
                <span class="synIdentifier">$self-&gt;_fix_single_metaclass_incompatibility</span>(
                    <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super</span>
                );
            }
        }
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_can_fix_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_class_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>) {
        <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_single_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>);
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_class_metaclass_can_be_made_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;_can_be_made_compatible_with</span>(<span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_single_metaclass_can_be_made_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$specific_meta</span> = <span class="synIdentifier">$self-&gt;$metaclass_type</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$super_meta-&gt;can</span>(<span class="synIdentifier">$metaclass_type</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$super_specific_meta</span> = <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;

    <span class="synComment"># for instance, Moose::Meta::Class has a destructor_class, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$super_specific_meta</span>;

    <span class="synComment"># if metaclass is defined in superclass but not here, it's fixable</span>
    <span class="synComment"># this is a really odd case</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$specific_meta</span>;

    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$specific_meta-&gt;_can_be_made_compatible_with</span>(<span class="synIdentifier">$super_specific_meta</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_class_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$super_meta</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$self-&gt;_class_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>)) {
        (<span class="synIdentifier">$self-&gt;is_pristine</span>)
            || confess <span class="synString">&quot;Can't fix metaclass incompatibility for &quot;</span>
                     . <span class="synIdentifier">$self-&gt;name</span>
                     . <span class="synString">&quot; because it is not pristine.&quot;</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_name</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

        <span class="synIdentifier">$self-&gt;_make_compatible_with</span>(<span class="synIdentifier">$super_meta_name</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_single_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super_meta</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$self-&gt;_single_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>)) {
        (<span class="synIdentifier">$self-&gt;is_pristine</span>)
            || confess <span class="synString">&quot;Can't fix metaclass incompatibility for &quot;</span>
                     . <span class="synIdentifier">$self-&gt;name</span>
                     . <span class="synString">&quot; because it is not pristine.&quot;</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$new_metaclass</span> = <span class="synIdentifier">$self-&gt;$metaclass_type</span>
            ? <span class="synIdentifier">$self-&gt;$metaclass_type-&gt;_get_compatible_metaclass</span>(<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>)
            : <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;
        <span class="synIdentifier">$self-&gt;{$metaclass_type}</span> = <span class="synIdentifier">$new_metaclass</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_restore_metaobjects_from </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$old_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;_restore_metamethods_from</span>(<span class="synIdentifier">$old_meta</span>);
    <span class="synIdentifier">$self-&gt;_restore_metaattributes_from</span>(<span class="synIdentifier">$old_meta</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_remove_generated_metaobjects </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;get_attribute</span>(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_attribute_list</span>) {
        <span class="synIdentifier">$attr-&gt;remove_accessors</span>;
    }
}

<span class="synComment"># creating classes with MOP ...</span>

<span class="synKeyword">sub </span><span class="synFunction">create </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@args</span> = <span class="synIdentifier">@_</span>;

    <span class="synStatement">unshift</span> <span class="synIdentifier">@args</span>, <span class="synString">'package'</span> <span class="synConditional">if</span> <span class="synIdentifier">@args</span> % <span class="synNumber">2</span> == <span class="synNumber">1</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@args</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>)
        || confess <span class="synString">&quot;You must pass an ARRAY ref of superclasses&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>)
        || confess <span class="synString">&quot;You must pass an ARRAY ref of attributes&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>)
        || confess <span class="synString">&quot;You must pass a HASH ref of methods&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$package</span>      = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$superclasses</span> = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$attributes</span>   = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$methods</span>      = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span>    = <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span>
                         ? <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span>
                         : <span class="synString">'meta'</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;SUPER</span>::create(<span class="synIdentifier">$package</span> =&gt; <span class="synIdentifier">%options</span>);

    <span class="synIdentifier">$meta-&gt;_add_meta_method</span>(<span class="synIdentifier">$meta_name</span>)
        <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$meta_name</span>;

    <span class="synIdentifier">$meta-&gt;superclasses</span>(<span class="synIdentifier">@{$superclasses}</span>)
        <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$superclasses</span>;
    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># process attributes first, so that they can</span>
    <span class="synComment"># install accessors, but locally defined methods</span>
    <span class="synComment"># can then overwrite them. It is maybe a little odd, but</span>
    <span class="synComment"># I think this should be the order of things.</span>
    <span class="synConditional">if</span> (<span class="synOperator">defined</span> <span class="synIdentifier">$attributes</span>) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">@{$attributes}</span>) {
            <span class="synIdentifier">$meta-&gt;add_attribute</span>(<span class="synIdentifier">$attr</span>);
        }
    }
    <span class="synConditional">if</span> (<span class="synOperator">defined</span> <span class="synIdentifier">$methods</span>) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$method_name</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%{$methods}</span>) {
            <span class="synIdentifier">$meta-&gt;add_method</span>(<span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$methods-&gt;{$method_name}</span>);
        }
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$meta</span>;
}

<span class="synComment"># </span><span class="synTodo">XXX:</span><span class="synComment"> something more intelligent here?</span>
<span class="synKeyword">sub </span><span class="synFunction">_anon_package_prefix </span>{ <span class="synString">'Class::MOP::Class::__ANON__::SERIAL::'</span> }

<span class="synKeyword">sub </span><span class="synFunction">create_anon_class </span>{ <span class="synStatement">shift</span>-&gt;create_anon(<span class="synIdentifier">@_</span>) }
<span class="synKeyword">sub </span><span class="synFunction">is_anon_class     </span>{ <span class="synStatement">shift</span>-&gt;is_anon(<span class="synIdentifier">@_</span>)     }

<span class="synKeyword">sub </span><span class="synFunction">_anon_cache_key </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@_</span>;
    <span class="synComment"># Makes something like Super::Class|Super::Class::2</span>
    <span class="synStatement">return</span> <span class="synStatement">join</span> <span class="synString">'='</span> =&gt; (
        <span class="synStatement">join</span>( <span class="synString">'|'</span>, <span class="synStatement">sort</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span> || [] <span class="synIdentifier">}</span> ),
    );
}

<span class="synComment"># Instance Construction &amp; Cloning</span>

<span class="synKeyword">sub </span><span class="synFunction">new_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to protect the integrity of the</span>
    <span class="synComment"># Class::MOP::Class singletons here, so we</span>
    <span class="synComment"># delegate this to &amp;construct_class_instance</span>
    <span class="synComment"># which will deal with the singletons</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$class-&gt;_construct_class_instance</span>(<span class="synIdentifier">@_</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$class-&gt;name-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$class-&gt;_construct_instance</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_construct_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$params</span> = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$class-&gt;get_meta_instance</span>();
    <span class="synComment"># </span><span class="synTodo">FIXME:</span>
    <span class="synComment"># the code below is almost certainly incorrect</span>
    <span class="synComment"># but this is foreign inheritance, so we might</span>
    <span class="synComment"># have to kludge it in the end.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span>;
    <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">$instance_class</span> = blessed(<span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>)) {
        (<span class="synIdentifier">$instance_class</span> <span class="synOperator">eq</span> <span class="synIdentifier">$class-&gt;name</span>)
            || confess <span class="synString">&quot;Objects passed as the __INSTANCE__ parameter must &quot;</span>
                     . <span class="synString">&quot;already be blessed into the correct class, but &quot;</span>
                     . <span class="synString">&quot;</span><span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span><span class="synString"> is not a &quot;</span> . <span class="synIdentifier">$class-&gt;name</span>;
        <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>) {
        confess <span class="synString">&quot;The __INSTANCE__ parameter must be a blessed reference, not &quot;</span>
              . <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$meta_instance-&gt;create_instance</span>();
    }
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$class-&gt;get_all_attributes</span>()) {
        <span class="synIdentifier">$attr-&gt;initialize_instance_slot</span>(<span class="synIdentifier">$meta_instance</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">$params</span>);
    }
    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$class-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_set_mop_slot</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$class</span>);
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_new_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> (
        <span class="synString">'my $class = shift;'</span>,
        <span class="synString">'$class = Scalar::Util::blessed($class) || $class;'</span>,
        <span class="synIdentifier">$self-&gt;_inline_fallback_constructor</span>(<span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_params</span>(<span class="synString">'$params'</span>, <span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_generate_instance</span>(<span class="synString">'$instance'</span>, <span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_slot_initializers</span>,
        <span class="synIdentifier">$self-&gt;_inline_preserve_weak_metaclasses</span>,
        <span class="synIdentifier">$self-&gt;_inline_extra_init</span>,
        <span class="synString">'return $instance'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_fallback_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'return '</span> . <span class="synIdentifier">$self-&gt;_generate_fallback_constructor</span>(<span class="synIdentifier">$class</span>),
            <span class="synString">'if '</span> . <span class="synIdentifier">$class</span> . <span class="synString">' ne \''</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">'\';'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_generate_fallback_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> <span class="synString">'Class::MOP::Class-&gt;initialize('</span> . <span class="synIdentifier">$class</span> . <span class="synString">')-&gt;new_object(@_)'</span>,
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_params </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$params</span>, <span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'my '</span> . <span class="synIdentifier">$params</span> . <span class="synString">' = @_ == 1 ? $_[0] : {@_};'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_generate_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$inst</span>, <span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'my '</span> . <span class="synIdentifier">$inst</span> . <span class="synString">' = '</span> . <span class="synIdentifier">$self-&gt;_inline_create_instance</span>(<span class="synIdentifier">$class</span>) . <span class="synString">';'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_create_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;inline_create_instance</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_slot_initializers </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$idx</span> = <span class="synNumber">0</span>;

    <span class="synStatement">return</span> <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;_inline_slot_initializer</span>(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$idx</span>++) <span class="synStatement">}</span>
               <span class="synStatement">sort</span> <span class="synStatement">{</span> <span class="synIdentifier">$a-&gt;name</span> <span class="synOperator">cmp</span> <span class="synIdentifier">$b-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_attributes</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_slot_initializer </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>  = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synOperator">defined</span>(<span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">@source</span> = (
            <span class="synString">'if (exists $params-&gt;{\''</span> . <span class="synIdentifier">$init_arg</span> . <span class="synString">'\'}) {'</span>,
                <span class="synIdentifier">$self-&gt;_inline_init_attr_from_constructor</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>),
            <span class="synString">'}'</span>,
        );
        <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">@default</span> = <span class="synIdentifier">$self-&gt;_inline_init_attr_from_default</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>)) {
            <span class="synStatement">push</span> <span class="synIdentifier">@source</span>, (
                <span class="synString">'else {'</span>,
                    <span class="synIdentifier">@default</span>,
                <span class="synString">'}'</span>,
            );
        }
        <span class="synStatement">return</span> <span class="synIdentifier">@source</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synStatement">my</span> <span class="synIdentifier">@default</span> = <span class="synIdentifier">$self-&gt;_inline_init_attr_from_default</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>)) {
        <span class="synStatement">return</span> (
            <span class="synString">'{'</span>,
                <span class="synIdentifier">@default</span>,
            <span class="synString">'}'</span>,
        );
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> ();
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_init_attr_from_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@initial_value</span> = <span class="synIdentifier">$attr-&gt;_inline_set_value</span>(
        <span class="synString">'$instance'</span>, <span class="synString">'$params-&gt;{\''</span> . <span class="synIdentifier">$attr-&gt;init_arg</span> . <span class="synString">'\'}'</span>,
    );

    <span class="synStatement">push</span> <span class="synIdentifier">@initial_value</span>, (
        <span class="synString">'$attrs-&gt;['</span> . <span class="synIdentifier">$idx</span> . <span class="synString">']-&gt;set_initial_value('</span>,
            <span class="synString">'$instance,'</span>,
            <span class="synIdentifier">$attr-&gt;_inline_instance_get</span>(<span class="synString">'$instance'</span>),
        <span class="synString">');'</span>,
    ) <span class="synConditional">if</span> <span class="synIdentifier">$attr-&gt;has_initializer</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@initial_value</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_init_attr_from_default </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$default</span> = <span class="synIdentifier">$self-&gt;_inline_default_value</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>);
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$default</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@initial_value</span> = <span class="synIdentifier">$attr-&gt;_inline_set_value</span>(<span class="synString">'$instance'</span>, <span class="synIdentifier">$default</span>);

    <span class="synStatement">push</span> <span class="synIdentifier">@initial_value</span>, (
        <span class="synString">'$attrs-&gt;['</span> . <span class="synIdentifier">$idx</span> . <span class="synString">']-&gt;set_initial_value('</span>,
            <span class="synString">'$instance,'</span>,
            <span class="synIdentifier">$attr-&gt;_inline_instance_get</span>(<span class="synString">'$instance'</span>),
        <span class="synString">');'</span>,
    ) <span class="synConditional">if</span> <span class="synIdentifier">$attr-&gt;has_initializer</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@initial_value</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_default_value </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$index</span>) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$attr-&gt;has_default</span>) {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># default values can either be CODE refs</span>
        <span class="synComment"># in which case we need to call them. Or</span>
        <span class="synComment"># they can be scalars (strings/numbers)</span>
        <span class="synComment"># in which case we can just deal with them</span>
        <span class="synComment"># in the code we eval.</span>
        <span class="synConditional">if</span> (<span class="synIdentifier">$attr-&gt;is_default_a_coderef</span>) {
            <span class="synStatement">return</span> <span class="synString">'$defaults-&gt;['</span> . <span class="synIdentifier">$index</span> . <span class="synString">']-&gt;($instance)'</span>;
        }
        <span class="synConditional">else</span> {
            <span class="synStatement">return</span> <span class="synString">'$defaults-&gt;['</span> . <span class="synIdentifier">$index</span> . <span class="synString">']'</span>;
        }
    }
    <span class="synConditional">elsif</span> (<span class="synIdentifier">$attr-&gt;has_builder</span>) {
        <span class="synStatement">return</span> <span class="synString">'$instance-&gt;'</span> . <span class="synIdentifier">$attr-&gt;builder</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_preserve_weak_metaclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$self-&gt;name</span>)) {
        <span class="synStatement">return</span> (
            <span class="synIdentifier">$self-&gt;_inline_set_mop_slot</span>(
                <span class="synString">'$instance'</span>, <span class="synString">'Class::MOP::class_of($class)'</span>
            ) . <span class="synString">';'</span>
        );
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> ();
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_extra_init </span>{ }

<span class="synKeyword">sub </span><span class="synFunction">_eval_environment </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@attrs</span> = <span class="synStatement">sort</span> <span class="synStatement">{</span> <span class="synIdentifier">$a-&gt;name</span> <span class="synOperator">cmp</span> <span class="synIdentifier">$b-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_attributes</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$defaults</span> = [<span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;default</span> <span class="synStatement">}</span> <span class="synIdentifier">@attrs</span>];

    <span class="synStatement">return</span> {
        <span class="synString">'$defaults'</span> =&gt; \<span class="synIdentifier">$defaults</span>,
    };
}


<span class="synKeyword">sub </span><span class="synFunction">get_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;{</span><span class="synString">'_meta_instance'</span><span class="synIdentifier">}</span> ||= <span class="synIdentifier">$self-&gt;_create_meta_instance</span>();
}

<span class="synKeyword">sub </span><span class="synFunction">_create_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$self-&gt;instance_metaclass-&gt;new</span>(
        <span class="synString">associated_metaclass</span> =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">attributes</span> =&gt; [ <span class="synIdentifier">$self-&gt;get_all_attributes</span>() ],
    );

    <span class="synIdentifier">$self-&gt;add_meta_instance_dependencies</span>()
        <span class="synConditional">if</span> <span class="synIdentifier">$instance-&gt;is_dependent_on_superclasses</span>();

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synComment"># </span><span class="synTodo">TODO:</span><span class="synComment"> this is actually not being used!</span>
<span class="synKeyword">sub </span><span class="synFunction">_inline_rebless_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;inline_rebless_instance_structure</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_get_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_get_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_set_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_set_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_clear_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_clear_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">clone_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>    = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span> = <span class="synStatement">shift</span>;
    (blessed(<span class="synIdentifier">$instance</span>) &amp;&amp; <span class="synIdentifier">$instance-&gt;isa</span>(<span class="synIdentifier">$class-&gt;name</span>))
        || confess <span class="synString">&quot;You must pass an instance of the metaclass (&quot;</span> . (<span class="synOperator">ref</span> <span class="synIdentifier">$class</span> ? <span class="synIdentifier">$class-&gt;name</span> : <span class="synIdentifier">$class</span>) . <span class="synString">&quot;), not (</span><span class="synIdentifier">$instance</span><span class="synString">)&quot;</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to protect the integrity of the</span>
    <span class="synComment"># Class::MOP::Class singletons here, they</span>
    <span class="synComment"># should not be cloned.</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span> <span class="synConditional">if</span> <span class="synIdentifier">$instance-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synIdentifier">$class-&gt;_clone_instance</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_clone_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    (blessed(<span class="synIdentifier">$instance</span>))
        || confess <span class="synString">&quot;You can only clone instances, (</span><span class="synIdentifier">$instance</span><span class="synString">) is not a blessed instance&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$class-&gt;get_meta_instance</span>();
    <span class="synStatement">my</span> <span class="synIdentifier">$clone</span> = <span class="synIdentifier">$meta_instance-&gt;clone_instance</span>(<span class="synIdentifier">$instance</span>);
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$class-&gt;get_all_attributes</span>()) {
        <span class="synConditional">if</span> ( <span class="synOperator">defined</span>( <span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span> ) ) {
            <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$params{$init_arg}</span>) {
                <span class="synIdentifier">$attr-&gt;set_value</span>(<span class="synIdentifier">$clone</span>, <span class="synIdentifier">$params{$init_arg}</span>);
            }
        }
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$clone</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_force_rebless_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synIdentifier">$old_metaclass-&gt;rebless_instance_away</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$self</span>, <span class="synIdentifier">%params</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$self-&gt;get_meta_instance</span>;

    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$old_metaclass-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_clear_mop_slot</span>(<span class="synIdentifier">$instance</span>);
    }

    <span class="synComment"># rebless!</span>
    <span class="synComment"># we use $_[1] here because of t/cmop/rebless_overload.t regressions</span>
    <span class="synComment"># on 5.8.8</span>
    <span class="synIdentifier">$meta_instance-&gt;rebless_instance_structure</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>, <span class="synIdentifier">$self</span>);

    <span class="synIdentifier">$self-&gt;_fixup_attributes_after_rebless</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$old_metaclass</span>, <span class="synIdentifier">%params</span>);

    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$self-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_set_mop_slot</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$self</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$old_class</span> = <span class="synIdentifier">$old_metaclass</span> ? <span class="synIdentifier">$old_metaclass-&gt;name</span> : blessed(<span class="synIdentifier">$instance</span>);
    <span class="synIdentifier">$self-&gt;name-&gt;isa</span>(<span class="synIdentifier">$old_class</span>)
        || confess <span class="synString">&quot;You may rebless only into a subclass of (</span><span class="synIdentifier">$old_class</span><span class="synString">), of which (&quot;</span>. <span class="synIdentifier">$self-&gt;name</span> .<span class="synString">&quot;) isn't.&quot;</span>;

    <span class="synIdentifier">$self-&gt;_force_rebless_instance</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>, <span class="synIdentifier">%params</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance_back </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$old_class</span>
        = <span class="synIdentifier">$old_metaclass</span> ? <span class="synIdentifier">$old_metaclass-&gt;name</span> : blessed(<span class="synIdentifier">$instance</span>);
    <span class="synIdentifier">$old_class-&gt;isa</span>( <span class="synIdentifier">$self-&gt;name</span> )
        || confess
        <span class="synString">&quot;You may rebless only into a superclass of (</span><span class="synIdentifier">$old_class</span><span class="synString">), of which (&quot;</span>
        . <span class="synIdentifier">$self-&gt;name</span>
        . <span class="synString">&quot;) isn't.&quot;</span>;

    <span class="synIdentifier">$self-&gt;_force_rebless_instance</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance_away </span>{
    <span class="synComment"># this intentionally does nothing, it is just a hook</span>
}

<span class="synKeyword">sub </span><span class="synFunction">_fixup_attributes_after_rebless </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$rebless_from</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$self-&gt;get_meta_instance</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> ( <span class="synIdentifier">$rebless_from-&gt;get_all_attributes</span> ) {
        <span class="synStatement">next</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;find_attribute_by_name</span>( <span class="synIdentifier">$attr-&gt;name</span> );
        <span class="synIdentifier">$meta_instance-&gt;deinitialize_slot</span>( <span class="synIdentifier">$instance</span>, <span class="synIdentifier">$_</span> ) <span class="synRepeat">for</span> <span class="synIdentifier">$attr-&gt;slots</span>;
    }

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> ( <span class="synIdentifier">$self-&gt;get_all_attributes</span> ) {
        <span class="synConditional">if</span> ( <span class="synIdentifier">$attr-&gt;has_value</span>(<span class="synIdentifier">$instance</span>) ) {
            <span class="synConditional">if</span> ( <span class="synOperator">defined</span>( <span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span> ) ) {
                <span class="synIdentifier">$params{$init_arg}</span> = <span class="synIdentifier">$attr-&gt;get_value</span>(<span class="synIdentifier">$instance</span>)
                    <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$params{$init_arg}</span>;
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$attr-&gt;set_value</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$attr-&gt;get_value</span>(<span class="synIdentifier">$instance</span>));
            }
        }
    }

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$self-&gt;get_all_attributes</span>) {
        <span class="synIdentifier">$attr-&gt;initialize_instance_slot</span>(<span class="synIdentifier">$meta_instance</span>, <span class="synIdentifier">$instance</span>, \<span class="synIdentifier">%params</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_attach_attribute </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$attribute</span>) = <span class="synIdentifier">@_</span>;
    <span class="synIdentifier">$attribute-&gt;attach_to_class</span>(<span class="synIdentifier">$self</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_post_add_attribute </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$attribute</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;invalidate_meta_instances</span>;

    <span class="synComment"># invalidate package flag here</span>
    try {
        <span class="synStatement">local</span> <span class="synIdentifier">$SIG{</span><span class="synString">__DIE__</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$attribute-&gt;install_accessors</span>;
    }
    catch {
        <span class="synIdentifier">$self-&gt;remove_attribute</span>( <span class="synIdentifier">$attribute-&gt;name</span> );
        <span class="synStatement">die</span> <span class="synIdentifier">$_</span>;
    };
}

<span class="synKeyword">sub </span><span class="synFunction">remove_attribute </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$removed_attribute</span> = <span class="synIdentifier">$self-&gt;SUPER</span>::remove_attribute(<span class="synIdentifier">@_</span>)
        <span class="synOperator">or</span> <span class="synStatement">return</span>;

    <span class="synIdentifier">$self-&gt;invalidate_meta_instances</span>;

    <span class="synIdentifier">$removed_attribute-&gt;remove_accessors</span>;
    <span class="synIdentifier">$removed_attribute-&gt;detach_from_class</span>;

    <span class="synStatement">return</span><span class="synIdentifier">$removed_attribute</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_attribute_by_name </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$attr_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> ( <span class="synIdentifier">$self-&gt;linearized_isa</span> ) {
        <span class="synComment"># fetch the meta-class ...</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$meta-&gt;get_attribute</span>(<span class="synIdentifier">$attr_name</span>)
            <span class="synConditional">if</span> <span class="synIdentifier">$meta-&gt;has_attribute</span>(<span class="synIdentifier">$attr_name</span>);
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_attributes </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%attrs</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">%{</span> Class::MOP::Class<span class="synIdentifier">-&gt;initialize($_)-&gt;_attribute_map</span> <span class="synIdentifier">}</span> <span class="synStatement">}</span>
        <span class="synStatement">reverse</span> <span class="synIdentifier">$self-&gt;linearized_isa</span>;
    <span class="synStatement">return</span> <span class="synStatement">values</span> <span class="synIdentifier">%attrs</span>;
}

<span class="synComment"># Inheritance</span>

<span class="synKeyword">sub </span><span class="synFunction">superclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>     = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$isa</span> = <span class="synIdentifier">$self-&gt;get_or_add_package_symbol</span>(<span class="synString">'@ISA'</span>);

    <span class="synConditional">if</span> (<span class="synIdentifier">@_</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">@supers</span> = <span class="synIdentifier">@_</span>;
        <span class="synIdentifier">@{$isa}</span> = <span class="synIdentifier">@supers</span>;

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># on 5.8 and below, we need to call</span>
        <span class="synComment"># a method to get Perl to detect</span>
        <span class="synComment"># a cycle in the class hierarchy</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synIdentifier">$class-&gt;isa</span>(<span class="synIdentifier">$class</span>);

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># we need to check the metaclass</span>
        <span class="synComment"># compatibility here so that we can</span>
        <span class="synComment"># be sure that the superclass is</span>
        <span class="synComment"># not potentially creating an issues</span>
        <span class="synComment"># we don't know about</span>

        <span class="synIdentifier">$self-&gt;_check_metaclass_compatibility</span>();
        <span class="synIdentifier">$self-&gt;_superclasses_updated</span>();
    }

    <span class="synStatement">return</span> <span class="synIdentifier">@{$isa}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_superclasses_updated </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;update_meta_instance_dependencies</span>();
    <span class="synComment"># keep strong references to all our parents, so they don't disappear if</span>
    <span class="synComment"># they are anon classes and don't have any direct instances</span>
    <span class="synIdentifier">$self-&gt;_superclass_metas</span>(
        <span class="synStatement">map</span> <span class="synStatement">{</span> Class::MOP::class_of(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;superclasses</span>
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_superclass_metas </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;{</span><span class="synString">_superclass_metas</span><span class="synIdentifier">}</span> = [<span class="synIdentifier">@_</span>];
}

<span class="synKeyword">sub </span><span class="synFunction">subclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$super_class</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$super_class-&gt;mro</span>::get_isarev() <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">direct_subclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$super_class</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synStatement">return</span> <span class="synStatement">grep</span> <span class="synStatement">{</span>
        <span class="synStatement">grep</span> <span class="synStatement">{</span>
            <span class="synIdentifier">$_</span> <span class="synOperator">eq</span> <span class="synIdentifier">$super_class</span>
        <span class="synStatement">}</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>)-&gt;superclasses
    <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;subclasses</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">linearized_isa </span>{
    <span class="synStatement">return</span> <span class="synIdentifier">@{</span> mro::get_linear_isa( (<span class="synStatement">shift</span>)-&gt;name ) <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">class_precedence_list </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synConditional">unless</span> (Class::MOP::IS_RUNNING_ON_5_10()) {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># We need to check for circular inheritance here</span>
        <span class="synComment"># if we are not on 5.10, cause 5.8 detects it late.</span>
        <span class="synComment"># This will do nothing if all is well, and blow up</span>
        <span class="synComment"># otherwise. Yes, it's an ugly hack, better</span>
        <span class="synComment"># suggestions are welcome.</span>
        <span class="synComment"># - SL</span>
        (<span class="synIdentifier">$name</span> || <span class="synStatement">return</span>)-&gt;isa(<span class="synString">'This is a test for circular inheritance'</span>)
    }

    <span class="synComment"># if our mro is c3, we can</span>
    <span class="synComment"># just grab the linear_isa</span>
    <span class="synConditional">if</span> (mro::get_mro(<span class="synIdentifier">$name</span>) <span class="synOperator">eq</span> <span class="synString">'c3'</span>) {
        <span class="synStatement">return</span> <span class="synIdentifier">@{</span> mro::get_linear_isa(<span class="synIdentifier">$name</span>) <span class="synIdentifier">}</span>
    }
    <span class="synConditional">else</span> {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># we can't grab the linear_isa for dfs</span>
        <span class="synComment"># since it has all the duplicates</span>
        <span class="synComment"># already removed.</span>
        <span class="synStatement">return</span> (
            <span class="synIdentifier">$name</span>,
            <span class="synStatement">map</span> <span class="synStatement">{</span>
                Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>)-&gt;class_precedence_list()
            <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;superclasses</span>()
        );
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_method_lookup_order </span>{
    <span class="synStatement">return</span> (<span class="synStatement">shift</span>-&gt;linearized_isa, <span class="synString">'UNIVERSAL'</span>);
}

<span class="synComment">## Methods</span>

{
    <span class="synStatement">my</span> <span class="synIdentifier">$fetch_and_prepare_method</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$wrapped_metaclass</span> = <span class="synIdentifier">$self-&gt;wrapped_method_metaclass</span>;
        <span class="synComment"># fetch it locally</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$self-&gt;get_method</span>(<span class="synIdentifier">$method_name</span>);
        <span class="synComment"># if we don't have local ...</span>
        <span class="synConditional">unless</span> (<span class="synIdentifier">$method</span>) {
            <span class="synComment"># try to find the next method</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$self-&gt;find_next_method_by_name</span>(<span class="synIdentifier">$method_name</span>);
            <span class="synComment"># die if it does not exist</span>
            (<span class="synOperator">defined</span> <span class="synIdentifier">$method</span>)
                || confess <span class="synString">&quot;The method '</span><span class="synIdentifier">$method_name</span><span class="synString">' was not found in the inheritance hierarchy for &quot;</span> . <span class="synIdentifier">$self-&gt;name</span>;
            <span class="synComment"># and now make sure to wrap it</span>
            <span class="synComment"># even if it is already wrapped</span>
            <span class="synComment"># because we need a new sub ref</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$wrapped_metaclass-&gt;wrap</span>(<span class="synIdentifier">$method</span>,
                <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
                <span class="synString">name</span>         =&gt; <span class="synIdentifier">$method_name</span>,
            );
        }
        <span class="synConditional">else</span> {
            <span class="synComment"># now make sure we wrap it properly</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$wrapped_metaclass-&gt;wrap</span>(<span class="synIdentifier">$method</span>,
                <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
                <span class="synString">name</span>         =&gt; <span class="synIdentifier">$method_name</span>,
            ) <span class="synConditional">unless</span> <span class="synIdentifier">$method-&gt;isa</span>(<span class="synIdentifier">$wrapped_metaclass</span>);
        }
        <span class="synIdentifier">$self-&gt;add_method</span>(<span class="synIdentifier">$method_name</span> =&gt; <span class="synIdentifier">$method</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span>;
    };

    <span class="synKeyword">sub </span><span class="synFunction">add_before_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_before_modifier</span>(
            subname(<span class="synString">':before'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synKeyword">sub </span><span class="synFunction">add_after_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_after_modifier</span>(
            subname(<span class="synString">':after'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synKeyword">sub </span><span class="synFunction">add_around_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_around_modifier</span>(
            subname(<span class="synString">':around'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># the methods above used to be named like this:</span>
    <span class="synComment">#    ${pkg}::${method}:(before|after|around)</span>
    <span class="synComment"># but this proved problematic when using one modifier</span>
    <span class="synComment"># to wrap multiple methods (something which is likely</span>
    <span class="synComment"># to happen pretty regularly IMO). So instead of naming</span>
    <span class="synComment"># it like this, I have chosen to just name them purely</span>
    <span class="synComment"># with their modifier names, like so:</span>
    <span class="synComment">#    :(before|after|around)</span>
    <span class="synComment"># The fact is that in a stack trace, it will be fairly</span>
    <span class="synComment"># evident from the context what method they are attached</span>
    <span class="synComment"># to, and so don't need the fully qualified name.</span>
}

<span class="synKeyword">sub </span><span class="synFunction">find_method_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;get_method(<span class="synIdentifier">$method_name</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$method</span>;
    }
    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_methods </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%methods</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> ( <span class="synStatement">reverse</span> <span class="synIdentifier">$self-&gt;_method_lookup_order</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);

        <span class="synIdentifier">$methods{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synIdentifier">}</span> = <span class="synIdentifier">$_</span> <span class="synRepeat">for</span> <span class="synIdentifier">$meta-&gt;_get_local_methods</span>;
    }

    <span class="synStatement">return</span> <span class="synStatement">values</span> <span class="synIdentifier">%methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_method_names </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_all_methods_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@methods</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>) {
        <span class="synComment"># fetch the meta-class ...</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);
        <span class="synStatement">push</span> <span class="synIdentifier">@methods</span> =&gt; {
            <span class="synString">name</span>  =&gt; <span class="synIdentifier">$method_name</span>,
            <span class="synString">class</span> =&gt; <span class="synIdentifier">$class</span>,
            <span class="synString">code</span>  =&gt; <span class="synIdentifier">$meta-&gt;get_method</span>(<span class="synIdentifier">$method_name</span>)
        } <span class="synConditional">if</span> <span class="synIdentifier">$meta-&gt;has_method</span>(<span class="synIdentifier">$method_name</span>);
    }
    <span class="synStatement">return</span> <span class="synIdentifier">@methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_next_method_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@cpl</span> = (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>);
    <span class="synStatement">shift</span> <span class="synIdentifier">@cpl</span>; <span class="synComment"># discard ourselves</span>
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@cpl</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;get_method(<span class="synIdentifier">$method_name</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$method</span>;
    }
    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">update_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;add_meta_instance_dependencies</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">add_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synIdentifier">$self-&gt;remove_meta_instance_dependencies</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@attrs</span> = <span class="synIdentifier">$self-&gt;get_all_attributes</span>();

    <span class="synStatement">my</span> <span class="synIdentifier">%seen</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@classes</span> = <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synOperator">not</span> <span class="synIdentifier">$seen{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synIdentifier">}</span>++ <span class="synStatement">}</span>
        <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;associated_class</span> <span class="synStatement">}</span> <span class="synIdentifier">@attrs</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@classes</span>) {
        <span class="synIdentifier">$class-&gt;add_dependent_meta_instance</span>(<span class="synIdentifier">$self</span>);
    }

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> = \<span class="synIdentifier">@classes</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">remove_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$classes</span> = <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> ) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@$classes</span>) {
            <span class="synIdentifier">$class-&gt;remove_dependent_meta_instance</span>(<span class="synIdentifier">$self</span>);
        }

        <span class="synStatement">return</span> <span class="synIdentifier">$classes</span>;
    }

    <span class="synStatement">return</span>;

}

<span class="synKeyword">sub </span><span class="synFunction">add_dependent_meta_instance </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$metaclass</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">push</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span> <span class="synIdentifier">}</span>, <span class="synIdentifier">$metaclass</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">remove_dependent_meta_instance </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$metaclass</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$metaclass-&gt;name</span>;
    <span class="synIdentifier">@$_</span> = <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synOperator">ne</span> <span class="synIdentifier">$name</span> <span class="synStatement">}</span> <span class="synIdentifier">@$_</span>
        <span class="synRepeat">for</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">invalidate_meta_instances </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$_-&gt;invalidate_meta_instance</span>()
        <span class="synRepeat">for</span> <span class="synIdentifier">$self</span>, <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span> <span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">invalidate_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synOperator">undef</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">_meta_instance</span><span class="synIdentifier">}</span>;
}

<span class="synComment"># check if we can reinitialize</span>
<span class="synKeyword">sub </span><span class="synFunction">is_pristine </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># if any local attr is defined</span>
    <span class="synStatement">return</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;get_attribute_list</span>;

    <span class="synComment"># or any non-declared methods</span>
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$method</span> ( <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;get_method</span>(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_method_list</span> ) {
        <span class="synStatement">return</span> <span class="synConditional">if</span> <span class="synIdentifier">$method-&gt;isa</span>(<span class="synString">&quot;Class::MOP::Method::Generated&quot;</span>);
        <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> do we need to enforce this too? return unless $method-&gt;isa( $self-&gt;method_metaclass );</span>
    }

    <span class="synStatement">return</span> <span class="synNumber">1</span>;
}

<span class="synComment">## Class closing</span>

<span class="synKeyword">sub </span><span class="synFunction">is_mutable   </span>{ <span class="synNumber">1</span> }
<span class="synKeyword">sub </span><span class="synFunction">is_immutable </span>{ <span class="synNumber">0</span> }

<span class="synKeyword">sub </span><span class="synFunction">immutable_options </span>{ <span class="synIdentifier">%{</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">options</span><span class="synIdentifier">}</span> || {} <span class="synIdentifier">}</span> }

<span class="synKeyword">sub </span><span class="synFunction">_immutable_options </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> (
        <span class="synString">inline_accessors</span>   =&gt; <span class="synNumber">1</span>,
        <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">1</span>,
        <span class="synString">inline_destructor</span>  =&gt; <span class="synNumber">0</span>,
        <span class="synString">debug</span>              =&gt; <span class="synNumber">0</span>,
        <span class="synString">immutable_trait</span>    =&gt; <span class="synIdentifier">$self-&gt;immutable_trait</span>,
        <span class="synString">constructor_name</span>   =&gt; <span class="synIdentifier">$self-&gt;constructor_name</span>,
        <span class="synString">constructor_class</span>  =&gt; <span class="synIdentifier">$self-&gt;constructor_class</span>,
        <span class="synString">destructor_class</span>   =&gt; <span class="synIdentifier">$self-&gt;destructor_class</span>,
        <span class="synIdentifier">@args</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">make_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span> <span class="synConditional">unless</span> <span class="synIdentifier">$self-&gt;is_mutable</span>;

    <span class="synStatement">my</span> (<span class="synIdentifier">$file</span>, <span class="synIdentifier">$line</span>) = (<span class="synStatement">caller</span>)[<span class="synFloat">1..2</span>];

    <span class="synIdentifier">$self-&gt;_initialize_immutable</span>(
        <span class="synString">file</span> =&gt; <span class="synIdentifier">$file</span>,
        <span class="synString">line</span> =&gt; <span class="synIdentifier">$line</span>,
        <span class="synIdentifier">$self-&gt;_immutable_options</span>(<span class="synIdentifier">@args</span>),
    );
    <span class="synIdentifier">$self-&gt;_rebless_as_immutable</span>(<span class="synIdentifier">@args</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">make_mutable </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;is_immutable</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">@args</span> = <span class="synIdentifier">$self-&gt;immutable_options</span>;
        <span class="synIdentifier">$self-&gt;_rebless_as_mutable</span>();
        <span class="synIdentifier">$self-&gt;_remove_inlined_code</span>(<span class="synIdentifier">@args</span>);
        <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_rebless_as_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">original_class</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$self</span>;

    <span class="synOperator">bless</span> <span class="synIdentifier">$self</span> =&gt; <span class="synIdentifier">$self-&gt;_immutable_metaclass</span>(<span class="synIdentifier">@args</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_immutable_metaclass </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$args{</span><span class="synString">immutable_metaclass</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$class</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$trait</span> = <span class="synIdentifier">$args{</span><span class="synString">immutable_trait</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$self-&gt;immutable_trait</span>
        || confess <span class="synString">&quot;no immutable trait specified for </span><span class="synIdentifier">$self</span><span class="synString">&quot;</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span>      = <span class="synIdentifier">$self-&gt;meta</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_attr</span> = <span class="synIdentifier">$meta-&gt;find_attribute_by_name</span>(<span class="synString">&quot;immutable_trait&quot;</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$class_name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$meta_attr</span> <span class="synOperator">and</span> <span class="synIdentifier">$trait</span> <span class="synOperator">eq</span> <span class="synIdentifier">$meta_attr-&gt;default</span> ) {
        <span class="synComment"># if the trait is the same as the default we try and pick a</span>
        <span class="synComment"># predictable name for the immutable metaclass</span>
        <span class="synIdentifier">$class_name</span> = <span class="synString">'Class::MOP::Class::Immutable::'</span> . <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$class_name</span> = <span class="synStatement">join</span> <span class="synString">'::'</span>, <span class="synString">'Class::MOP::Class::Immutable::CustomTrait'</span>,
            <span class="synIdentifier">$trait</span>, <span class="synString">'ForMetaClass'</span>, <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>);
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$class_name</span>
        <span class="synConditional">if</span> is_class_loaded(<span class="synIdentifier">$class_name</span>);

    <span class="synComment"># If the metaclass is a subclass of CMOP::Class which has had</span>
    <span class="synComment"># metaclass roles applied (via Moose), then we want to make sure</span>
    <span class="synComment"># that we preserve that anonymous class (see Fey::ORM for an</span>
    <span class="synComment"># example of where this matters).</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span> = <span class="synIdentifier">$meta-&gt;_real_ref_name</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$immutable_meta</span> = <span class="synIdentifier">$meta_name-&gt;create</span>(
        <span class="synIdentifier">$class_name</span>,
        <span class="synString">superclasses</span> =&gt; [ <span class="synOperator">ref</span> <span class="synIdentifier">$self</span> ],
    );

    Class::MOP::MiniTrait::apply( <span class="synIdentifier">$immutable_meta</span>, <span class="synIdentifier">$trait</span> );

    <span class="synIdentifier">$immutable_meta-&gt;make_immutable</span>(
        <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">0</span>,
        <span class="synString">inline_accessors</span>   =&gt; <span class="synNumber">0</span>,
    );

    <span class="synStatement">return</span> <span class="synIdentifier">$class_name</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_remove_inlined_code </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synIdentifier">$self-&gt;remove_method</span>( <span class="synIdentifier">$_-&gt;name</span> ) <span class="synRepeat">for</span> <span class="synIdentifier">$self-&gt;_inlined_methods</span>;

    <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inlined_methods </span>{ <span class="synIdentifier">@{</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span> || [] <span class="synIdentifier">}</span> }

<span class="synKeyword">sub </span><span class="synFunction">_add_inlined_method </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$method</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">push</span> <span class="synIdentifier">@{</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span> ||= [] <span class="synIdentifier">}</span>, <span class="synIdentifier">$method</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_initialize_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">options</span><span class="synIdentifier">}</span> = \<span class="synIdentifier">%args</span>;
    <span class="synIdentifier">$self-&gt;_install_inlined_code</span>(<span class="synIdentifier">%args</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_install_inlined_code </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synComment"># </span><span class="synTodo">FIXME</span>
    <span class="synIdentifier">$self-&gt;_inline_accessors</span>(<span class="synIdentifier">%args</span>)   <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_accessors</span><span class="synIdentifier">}</span>;
    <span class="synIdentifier">$self-&gt;_inline_constructor</span>(<span class="synIdentifier">%args</span>) <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_constructor</span><span class="synIdentifier">}</span>;
    <span class="synIdentifier">$self-&gt;_inline_destructor</span>(<span class="synIdentifier">%args</span>)  <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_destructor</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_rebless_as_mutable </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synOperator">bless</span> <span class="synIdentifier">$self</span>, <span class="synIdentifier">$self-&gt;_get_mutable_metaclass_name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_accessors </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr_name</span> ( <span class="synIdentifier">$self-&gt;get_attribute_list</span> ) {
        <span class="synIdentifier">$self-&gt;get_attribute</span>(<span class="synIdentifier">$attr_name</span>)-&gt;install_accessors(<span class="synNumber">1</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_constructor </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$args{</span><span class="synString">constructor_name</span><span class="synIdentifier">}</span>;
    <span class="synComment"># A class may not even have a constructor, and that's okay.</span>
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;has_method</span>(<span class="synIdentifier">$name</span>) &amp;&amp; !<span class="synIdentifier">$args{</span><span class="synString">replace_constructor</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synStatement">warn</span> <span class="synString">&quot;Not inlining a constructor for </span><span class="synIdentifier">$class</span><span class="synString"> since it defines&quot;</span>
            . <span class="synString">&quot; its own constructor.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>
            . <span class="synString">&quot;If you are certain you don't need to inline your&quot;</span>
            . <span class="synString">&quot; constructor, specify inline_constructor =&gt; 0 in your&quot;</span>
            . <span class="synString">&quot; call to </span><span class="synIdentifier">$class-&gt;meta-&gt;make_immutable</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$constructor_class</span> = <span class="synIdentifier">$args{</span><span class="synString">constructor_class</span><span class="synIdentifier">}</span>;

    load_class(<span class="synIdentifier">$constructor_class</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$constructor</span> = <span class="synIdentifier">$constructor_class-&gt;new</span>(
        <span class="synString">options</span>      =&gt; \<span class="synIdentifier">%args</span>,
        <span class="synString">metaclass</span>    =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">is_inline</span>    =&gt; <span class="synNumber">1</span>,
        <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
        <span class="synString">name</span>         =&gt; <span class="synIdentifier">$name</span>,
        <span class="synString">definition_context</span> =&gt; {
            <span class="synString">description</span> =&gt; <span class="synString">&quot;constructor &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot;::&quot;</span> . <span class="synIdentifier">$name</span>,
            <span class="synString">file</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">file</span><span class="synIdentifier">}</span>,
            <span class="synString">line</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">line</span><span class="synIdentifier">}</span>,
        },
    );

    <span class="synConditional">if</span> ( <span class="synIdentifier">$args{</span><span class="synString">replace_constructor</span><span class="synIdentifier">}</span> <span class="synOperator">or</span> <span class="synIdentifier">$constructor-&gt;can_be_inlined</span> ) {
        <span class="synIdentifier">$self-&gt;add_method</span>( <span class="synIdentifier">$name</span> =&gt; <span class="synIdentifier">$constructor</span> );
        <span class="synIdentifier">$self-&gt;_add_inlined_method</span>(<span class="synIdentifier">$constructor</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_destructor </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    ( <span class="synStatement">exists</span> <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span> )
        || confess <span class="synString">&quot;The 'inline_destructor' option is present, but &quot;</span>
        . <span class="synString">&quot;no destructor class was specified&quot;</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;has_method</span>(<span class="synString">'DESTROY'</span>) &amp;&amp; ! <span class="synIdentifier">$args{</span><span class="synString">replace_destructor</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synStatement">warn</span> <span class="synString">&quot;Not inlining a destructor for </span><span class="synIdentifier">$class</span><span class="synString"> since it defines&quot;</span>
            . <span class="synString">&quot; its own destructor.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$destructor_class</span> = <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span>;

    load_class(<span class="synIdentifier">$destructor_class</span>);

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$destructor_class-&gt;is_needed</span>(<span class="synIdentifier">$self</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$destructor</span> = <span class="synIdentifier">$destructor_class-&gt;new</span>(
        <span class="synString">options</span>      =&gt; \<span class="synIdentifier">%args</span>,
        <span class="synString">metaclass</span>    =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
        <span class="synString">name</span>         =&gt; <span class="synString">'DESTROY'</span>,
        <span class="synString">definition_context</span> =&gt; {
            <span class="synString">description</span> =&gt; <span class="synString">&quot;destructor &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot;::DESTROY&quot;</span>,
            <span class="synString">file</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">file</span><span class="synIdentifier">}</span>,
            <span class="synString">line</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">line</span><span class="synIdentifier">}</span>,
        },
    );

    <span class="synConditional">if</span> ( <span class="synIdentifier">$args{</span><span class="synString">replace_destructor</span><span class="synIdentifier">}</span> <span class="synOperator">or</span> <span class="synIdentifier">$destructor-&gt;can_be_inlined</span> ) {
        <span class="synIdentifier">$self-&gt;add_method</span>( <span class="synString">'DESTROY'</span> =&gt; <span class="synIdentifier">$destructor</span> );
        <span class="synIdentifier">$self-&gt;_add_inlined_method</span>(<span class="synIdentifier">$destructor</span>);
    }
}

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: Class Meta Object</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

Class::MOP::Class - Class Meta Object

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

version 2.1005

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synPreProc">  # assuming that class Foo</span>
<span class="synPreProc">  # has been defined, you can</span>

<span class="synPreProc">  # use this for introspection ...</span>

<span class="synPreProc">  # add a method to Foo ...</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;add_method( 'bar' =&gt; sub {...} )</span>

<span class="synPreProc">  # get a list of all the classes searched</span>
<span class="synPreProc">  # the method dispatcher in the correct order</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;class_precedence_list()</span>

<span class="synPreProc">  # remove a method from Foo</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;remove_method('bar');</span>

<span class="synPreProc">  # or use this to actually create classes ...</span>

<span class="synPreProc">  Class::MOP::Class-&gt;create(</span>
<span class="synPreProc">      'Bar' =&gt; (</span>
<span class="synPreProc">          version      =&gt; '0.01',</span>
<span class="synPreProc">          superclasses =&gt; ['Foo'],</span>
<span class="synPreProc">          attributes   =&gt; [</span>
<span class="synPreProc">              Class::MOP::Attribute-&gt;new('$bar'),</span>
<span class="synPreProc">              Class::MOP::Attribute-&gt;new('$baz'),</span>
<span class="synPreProc">          ],</span>
<span class="synPreProc">          methods =&gt; {</span>
<span class="synPreProc">              calculate_bar =&gt; sub {...},</span>
<span class="synPreProc">              construct_baz =&gt; sub {...}</span>
<span class="synPreProc">          }</span>
<span class="synPreProc">      )</span>
<span class="synPreProc">  );</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

The Class Protocol is the largest and most complex part of the
Class::MOP meta-object protocol. It controls the introspection and
manipulation of Perl 5 classes, and it can create them as well. The
best way to understand what this module can do is to read the
documentation for each of its methods.

<span class="synStatement">=head1</span><span class="synString"> INHERITANCE</span>

<span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span> is a subclass of <span class="synIdentifier">L&lt;Class::MOP::Module&gt;</span>.

<span class="synStatement">=head1</span><span class="synString"> METHODS</span>

<span class="synStatement">=head2</span><span class="synString"> Class construction</span>

These methods all create new <span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span> objects. These
objects can represent existing classes or they can be used to create
new classes from scratch.

The metaclass object for a given class is a singleton. If you attempt
to create a metaclass for the same class twice, you will just get the
existing object.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;create($package_name, %options) &gt;&gt;</span>

This method creates a new <span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span> object with the given
package name. It accepts a number of options:

<span class="synStatement">=over</span> <span class="synNumber">8</span>

<span class="synStatement">=item</span><span class="synString"> * version</span>

An optional version number for the newly created package.

<span class="synStatement">=item</span><span class="synString"> * authority</span>

An optional authority for the newly created package.

<span class="synStatement">=item</span><span class="synString"> * superclasses</span>

An optional array reference of superclass names.

<span class="synStatement">=item</span><span class="synString"> * methods</span>

An optional hash reference of methods for the class. The keys of the
hash reference are method names and values are subroutine references.

<span class="synStatement">=item</span><span class="synString"> * attributes</span>

An optional array reference of <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> objects.

<span class="synStatement">=item</span><span class="synString"> * meta_name</span>

Specifies the name to install the <span class="synIdentifier">C&lt;meta&gt;</span> method for this class under.
If it is not passed, <span class="synIdentifier">C&lt;meta&gt;</span> is assumed, and if <span class="synIdentifier">C&lt;undef&gt;</span> is explicitly
given, no meta method will be installed.

<span class="synStatement">=item</span><span class="synString"> * weaken</span>

If true, the metaclass that is stored in the global cache will be a
weak reference.

Classes created in this way are destroyed once the metaclass they are
attached to goes out of scope, and will be removed from Perl's internal
symbol table.

All instances of a class with a weakened metaclass keep a special
reference to the metaclass object, which prevents the metaclass from
going out of scope while any instances exist.

This only works if the instance is based on a hash reference, however.

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;create_anon_class(%options) &gt;&gt;</span>

This method works just like <span class="synIdentifier">C&lt;&lt; Class::MOP::Class-&gt;create &gt;&gt;</span> but it
creates an &quot;anonymous&quot; class. In fact, the class does have a name, but
that name is a unique name generated internally by this module.

It accepts the same <span class="synIdentifier">C&lt;superclasses&gt;</span>, <span class="synIdentifier">C&lt;methods&gt;</span>, and <span class="synIdentifier">C&lt;attributes&gt;</span>
parameters that <span class="synIdentifier">C&lt;create&gt;</span> accepts.

Anonymous classes default to <span class="synIdentifier">C&lt;&lt; weaken =&gt; 1 &gt;&gt;</span>, although this can be
overridden.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;initialize($package_name, %options) &gt;&gt;</span>

This method will initialize a <span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span> object for the
named package. Unlike <span class="synIdentifier">C&lt;create&gt;</span>, this method <span class="synIdentifier">I&lt;will not&gt;</span> create a new
class.

The purpose of this method is to retrieve a <span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span>
object for introspecting an existing class.

If an existing <span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span> object exists for the named
package, it will be returned, and any options provided will be
ignored!

If the object does not yet exist, it will be created.

The valid options that can be passed to this method are
<span class="synIdentifier">C&lt;attribute_metaclass&gt;</span>, <span class="synIdentifier">C&lt;method_metaclass&gt;</span>,
<span class="synIdentifier">C&lt;wrapped_method_metaclass&gt;</span>, and <span class="synIdentifier">C&lt;instance_metaclass&gt;</span>. These are all
optional, and default to the appropriate class in the <span class="synIdentifier">C&lt;Class::MOP&gt;</span>
distribution.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Object instance construction and cloning</span>

These methods are all related to creating and/or cloning object
instances.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;clone_object($instance, %params) &gt;&gt;</span>

This method clones an existing object instance. Any parameters you
provide are will override existing attribute values in the object.

This is a convenience method for cloning an object instance, then
blessing it into the appropriate package.

You could implement a clone method in your class, using this method:

<span class="synPreProc">  sub clone {</span>
<span class="synPreProc">      my ($self, %params) = @_;</span>
<span class="synPreProc">      $self-&gt;meta-&gt;clone_object($self, %params);</span>
<span class="synPreProc">  }</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;rebless_instance($instance, %params) &gt;&gt;</span>

This method changes the class of <span class="synIdentifier">C&lt;$instance&gt;</span> to the metaclass's class.

You can only rebless an instance into a subclass of its current
class. If you pass any additional parameters, these will be treated
like constructor parameters and used to initialize the object's
attributes. Any existing attributes that are already set will be
overwritten.

Before reblessing the instance, this method will call
<span class="synIdentifier">C&lt;rebless_instance_away&gt;</span> on the instance's current metaclass. This method
will be passed the instance, the new metaclass, and any parameters
specified to <span class="synIdentifier">C&lt;rebless_instance&gt;</span>. By default, <span class="synIdentifier">C&lt;rebless_instance_away&gt;</span>
does nothing; it is merely a hook.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;rebless_instance_back($instance) &gt;&gt;</span>

Does the same thing as <span class="synIdentifier">C&lt;rebless_instance&gt;</span>, except that you can only
rebless an instance into one of its superclasses. Any attributes that
do not exist in the superclass will be deinitialized.

This is a much more dangerous operation than <span class="synIdentifier">C&lt;rebless_instance&gt;</span>,
especially when multiple inheritance is involved, so use this carefully!

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;new_object(%params) &gt;&gt;</span>

This method is used to create a new object of the metaclass's
class. Any parameters you provide are used to initialize the
instance's attributes. A special <span class="synIdentifier">C&lt;__INSTANCE__&gt;</span> key can be passed to
provide an already generated instance, rather than having Class::MOP
generate it for you. This is mostly useful for using Class::MOP with
foreign classes which generate instances using their own constructors.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;instance_metaclass &gt;&gt;</span>

Returns the class name of the instance metaclass. See
<span class="synIdentifier">L&lt;Class::MOP::Instance&gt;</span> for more information on the instance
metaclass.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_meta_instance &gt;&gt;</span>

Returns an instance of the <span class="synIdentifier">C&lt;instance_metaclass&gt;</span> to be used in the
construction of a new instance of the class.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Informational predicates</span>

These are a few predicate methods for asking information about the
class itself.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_anon_class &gt;&gt;</span>

This returns true if the class was created by calling C&lt;&lt;
Class::MOP::Class-&gt;create_anon_class &gt;&gt;.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_mutable &gt;&gt;</span>

This returns true if the class is still mutable.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_immutable &gt;&gt;</span>

This returns true if the class has been made immutable.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_pristine &gt;&gt;</span>

A class is <span class="synIdentifier">I&lt;not&gt;</span> pristine if it has non-inherited attributes or if it
has any generated methods.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Inheritance Relationships</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;superclasses(@superclasses) &gt;&gt;</span>

This is a read-write accessor which represents the superclass
relationships of the metaclass's class.

This is basically sugar around getting and setting <span class="synIdentifier">C&lt;@ISA&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;class_precedence_list &gt;&gt;</span>

This returns a list of all of the class's ancestor classes. The
classes are returned in method dispatch order.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;linearized_isa &gt;&gt;</span>

This returns a list based on <span class="synIdentifier">C&lt;class_precedence_list&gt;</span> but with all
duplicates removed.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;subclasses &gt;&gt;</span>

This returns a list of all subclasses for this class, even indirect
subclasses.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;direct_subclasses &gt;&gt;</span>

This returns a list of immediate subclasses for this class, which does not
include indirect subclasses.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Method introspection and creation</span>

These methods allow you to introspect a class's methods, as well as
add, remove, or change methods.

Determining what is truly a method in a Perl 5 class requires some
heuristics (aka guessing).

Methods defined outside the package with a fully qualified name (C&lt;sub
Package::name { ... }&gt;) will be included. Similarly, methods named
with a fully qualified name using <span class="synIdentifier">L&lt;Sub::Name&gt;</span> are also included.

However, we attempt to ignore imported functions.

Ultimately, we are using heuristics to determine what truly is a
method in a class, and these heuristics may get the wrong answer in
some edge cases. However, for most &quot;normal&quot; cases the heuristics work
correctly.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_method($method_name) &gt;&gt;</span>

This will return a <span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> for the specified
<span class="synIdentifier">C&lt;$method_name&gt;</span>. If the class does not have the specified method, it
returns <span class="synIdentifier">C&lt;undef&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_method($method_name) &gt;&gt;</span>

Returns a boolean indicating whether or not the class defines the
named method. It does not include methods inherited from parent
classes.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_method_list &gt;&gt;</span>

This will return a list of method <span class="synIdentifier">I&lt;names&gt;</span> for all methods defined in
this class.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_method($method_name, $method) &gt;&gt;</span>

This method takes a method name and a subroutine reference, and adds
the method to the class.

The subroutine reference can be a <span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span>, and you are
strongly encouraged to pass a meta method object instead of a code
reference. If you do so, that object gets stored as part of the
class's method map directly. If not, the meta information will have to
be recreated later, and may be incorrect.

If you provide a method object, this method will clone that object if
the object's package name does not match the class name. This lets us
track the original source of any methods added from other classes
(notably Moose roles).

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_method($method_name) &gt;&gt;</span>

Remove the named method from the class. This method returns the
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> object for the method.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;method_metaclass &gt;&gt;</span>

Returns the class name of the method metaclass, see
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> for more information on the method metaclass.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;wrapped_method_metaclass &gt;&gt;</span>

Returns the class name of the wrapped method metaclass, see
<span class="synIdentifier">L&lt;Class::MOP::Method::Wrapped&gt;</span> for more information on the wrapped
method metaclass.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_methods &gt;&gt;</span>

This will traverse the inheritance hierarchy and return a list of all
the <span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> objects for this class and its parents.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_method_by_name($method_name) &gt;&gt;</span>

This will return a <span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> for the specified
<span class="synIdentifier">C&lt;$method_name&gt;</span>. If the class does not have the specified method, it
returns <span class="synIdentifier">C&lt;undef&gt;</span>

Unlike <span class="synIdentifier">C&lt;get_method&gt;</span>, this method <span class="synIdentifier">I&lt;will&gt;</span> look for the named method in
superclasses.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_method_names &gt;&gt;</span>

This will return a list of method <span class="synIdentifier">I&lt;names&gt;</span> for all of this class's
methods, including inherited methods.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_all_methods_by_name($method_name) &gt;&gt;</span>

This method looks for the named method in the class and all of its
parents. It returns every matching method it finds in the inheritance
tree, so it returns a list of methods.

Each method is returned as a hash reference with three keys. The keys
are <span class="synIdentifier">C&lt;name&gt;</span>, <span class="synIdentifier">C&lt;class&gt;</span>, and <span class="synIdentifier">C&lt;code&gt;</span>. The <span class="synIdentifier">C&lt;code&gt;</span> key has a
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span> object as its value.

The list of methods is distinct.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_next_method_by_name($method_name) &gt;&gt;</span>

This method returns the first method in any superclass matching the
given name. It is effectively the method that <span class="synIdentifier">C&lt;SUPER::$method_name&gt;</span>
would dispatch to.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Attribute introspection and creation</span>

Because Perl 5 does not have a core concept of attributes in classes,
we can only return information about attributes which have been added
via this class's methods. We cannot discover information about
attributes which are defined in terms of &quot;regular&quot; Perl 5 methods.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_attribute($attribute_name) &gt;&gt;</span>

This will return a <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> for the specified
<span class="synIdentifier">C&lt;$attribute_name&gt;</span>. If the class does not have the specified
attribute, it returns <span class="synIdentifier">C&lt;undef&gt;</span>.

<span class="synTodo">NOTE</span> that get_attribute does not search superclasses, for that you
need to use <span class="synIdentifier">C&lt;find_attribute_by_name&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_attribute($attribute_name) &gt;&gt;</span>

Returns a boolean indicating whether or not the class defines the
named attribute. It does not include attributes inherited from parent
classes.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_attribute_list &gt;&gt;</span>

This will return a list of attributes <span class="synIdentifier">I&lt;names&gt;</span> for all attributes
defined in this class.  Note that this operates on the current class
only, it does not traverse the inheritance hierarchy.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_attributes &gt;&gt;</span>

This will traverse the inheritance hierarchy and return a list of all
the <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> objects for this class and its parents.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_attribute_by_name($attribute_name) &gt;&gt;</span>

This will return a <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> for the specified
<span class="synIdentifier">C&lt;$attribute_name&gt;</span>. If the class does not have the specified
attribute, it returns <span class="synIdentifier">C&lt;undef&gt;</span>.

Unlike <span class="synIdentifier">C&lt;get_attribute&gt;</span>, this attribute <span class="synIdentifier">I&lt;will&gt;</span> look for the named
attribute in superclasses.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_attribute(...) &gt;&gt;</span>

This method accepts either an existing <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span>
object or parameters suitable for passing to that class's <span class="synIdentifier">C&lt;new&gt;</span>
method.

The attribute provided will be added to the class.

Any accessor methods defined by the attribute will be added to the
class when the attribute is added.

If an attribute of the same name already exists, the old attribute
will be removed first.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_attribute($attribute_name) &gt;&gt;</span>

This will remove the named attribute from the class, and
<span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span> object.

Removing an attribute also removes any accessor methods defined by the
attribute.

However, note that removing an attribute will only affect <span class="synIdentifier">I&lt;future&gt;</span>
object instances created for this class, not existing instances.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;attribute_metaclass &gt;&gt;</span>

Returns the class name of the attribute metaclass for this class. By
default, this is <span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span>.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Overload introspection and creation</span>

These methods provide an API to the core <span class="synIdentifier">L&lt;overload&gt;</span> functionality.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_overloaded &gt;&gt;</span>

Returns true if overloading is enabled for this class. Corresponds to
<span class="synIdentifier">L&lt;overload::Overloaded|overload/Public Functions&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_overloaded_operator($op) &gt;&gt;</span>

Returns the <span class="synIdentifier">L&lt;Class::MOP::Method::Overload&gt;</span> object corresponding to the
operator named <span class="synIdentifier">C&lt;$op&gt;</span>, if one exists for this class.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_overloaded_operator($op) &gt;&gt;</span>

Returns whether or not the operator <span class="synIdentifier">C&lt;$op&gt;</span> is overloaded for this class.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_overload_list &gt;&gt;</span>

Returns a list of operator names which have been overloaded (see
<span class="synIdentifier">L&lt;overload/Overloadable Operations&gt;</span> for the list of valid operator names).

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_overloaded_operators &gt;&gt;</span>

Returns a list of <span class="synIdentifier">L&lt;Class::MOP::Method::Overload&gt;</span> objects corresponding to the
operators that have been overloaded.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_overloaded_operator($op, $impl) &gt;&gt;</span>

Overloads the operator <span class="synIdentifier">C&lt;$op&gt;</span> for this class, with the implementation <span class="synIdentifier">C&lt;$impl&gt;</span>.
<span class="synIdentifier">C&lt;$impl&gt;</span> can be either a coderef or a method name. Corresponds to
<span class="synIdentifier">C&lt;&lt; use overload $op =&gt; $impl; &gt;&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_overloaded_operator($op) &gt;&gt;</span>

Remove overloading for operator <span class="synIdentifier">C&lt;$op&gt;</span>. Corresponds to <span class="synIdentifier">C&lt;&lt; no overload $op; &gt;&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Class Immutability</span>

Making a class immutable &quot;freezes&quot; the class definition. You can no
longer call methods which alter the class, such as adding or removing
methods or attributes.

Making a class immutable lets us optimize the class by inlining some
methods, and also allows us to optimize some methods on the metaclass
object itself.

After immutabilization, the metaclass object will cache most informational
methods that returns information about methods or attributes. Methods which
would alter the class, such as <span class="synIdentifier">C&lt;add_attribute&gt;</span> and <span class="synIdentifier">C&lt;add_method&gt;</span>, will
throw an error on an immutable metaclass object.

The immutabilization system in <span class="synIdentifier">L&lt;Moose&gt;</span> takes much greater advantage
of the inlining features than Class::MOP itself does.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;make_immutable(%options) &gt;&gt;</span>

This method will create an immutable transformer and use it to make
the class and its metaclass object immutable, and returns true
(you should not rely on the details of this value apart from its truth).

This method accepts the following options:

<span class="synStatement">=over</span> <span class="synNumber">8</span>

<span class="synStatement">=item</span><span class="synString"> * inline_accessors</span>

<span class="synStatement">=item</span><span class="synString"> * inline_constructor</span>

<span class="synStatement">=item</span><span class="synString"> * inline_destructor</span>

These are all booleans indicating whether the specified <span class="synIdentifier">method(s)</span>
should be inlined.

By default, accessors and the constructor are inlined, but not the
destructor.

<span class="synStatement">=item</span><span class="synString"> * immutable_trait</span>

The name of a class which will be used as a parent class for the
metaclass object being made immutable. This &quot;trait&quot; implements the
post-immutability functionality of the metaclass (but not the
transformation itself).

This defaults to <span class="synIdentifier">L&lt;Class::MOP::Class::Immutable::Trait&gt;</span>.

<span class="synStatement">=item</span><span class="synString"> * constructor_name</span>

This is the constructor method name. This defaults to &quot;new&quot;.

<span class="synStatement">=item</span><span class="synString"> * constructor_class</span>

The name of the method metaclass for constructors. It will be used to
generate the inlined constructor. This defaults to
&quot;Class::MOP::Method::Constructor&quot;.

<span class="synStatement">=item</span><span class="synString"> * replace_constructor</span>

This is a boolean indicating whether an existing constructor should be
replaced when inlining a constructor. This defaults to false.

<span class="synStatement">=item</span><span class="synString"> * destructor_class</span>

The name of the method metaclass for destructors. It will be used to
generate the inlined destructor. This defaults to
&quot;Class::MOP::Method::Denstructor&quot;.

<span class="synStatement">=item</span><span class="synString"> * replace_destructor</span>

This is a boolean indicating whether an existing destructor should be
replaced when inlining a destructor. This defaults to false.

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;immutable_options &gt;&gt;</span>

Returns a hash of the options used when making the class immutable, including
both defaults and anything supplied by the user in the call to C&lt;&lt;
<span class="synIdentifier">$metaclass</span>-&gt;make_immutable &gt;&gt;. This is useful if you need to temporarily make
a class mutable and then restore immutability as it was before.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;make_mutable &gt;&gt;</span>

Calling this method reverse the immutabilization transformation.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Method Modifiers</span>

Method modifiers are hooks which allow a method to be wrapped with
<span class="synIdentifier">I&lt;before&gt;</span>, <span class="synIdentifier">I&lt;after&gt;</span> and <span class="synIdentifier">I&lt;around&gt;</span> method modifiers. Every time a
method is called, its modifiers are also called.

A class can modify its own methods, as well as methods defined in
parent classes.

<span class="synStatement">=head3</span><span class="synString"> How method modifiers work?</span>

Method modifiers work by wrapping the original method and then
replacing it in the class's symbol table. The wrappers will handle
calling all the modifiers in the appropriate order and preserving the
calling context for the original method.

The return values of <span class="synIdentifier">C&lt;before&gt;</span> and <span class="synIdentifier">C&lt;after&gt;</span> modifiers are
ignored. This is because their purpose is <span class="synIdentifier">B&lt;not&gt;</span> to filter the input
and output of the primary method (this is done with an <span class="synIdentifier">I&lt;around&gt;</span>
modifier).

This may seem like an odd restriction to some, but doing this allows
for simple code to be added at the beginning or end of a method call
without altering the function of the wrapped method or placing any
extra responsibility on the code of the modifier.

Of course if you have more complex needs, you can use the <span class="synIdentifier">C&lt;around&gt;</span>
modifier which allows you to change both the parameters passed to the
wrapped method, as well as its return value.

Before and around modifiers are called in last-defined-first-called
order, while after modifiers are called in first-defined-first-called
order. So the call tree might looks something like this:

<span class="synPreProc">  before 2</span>
<span class="synPreProc">   before 1</span>
<span class="synPreProc">    around 2</span>
<span class="synPreProc">     around 1</span>
<span class="synPreProc">      primary</span>
<span class="synPreProc">     around 1</span>
<span class="synPreProc">    around 2</span>
<span class="synPreProc">   after 1</span>
<span class="synPreProc">  after 2</span>

<span class="synStatement">=head3</span><span class="synString"> What is the performance impact?</span>

Of course there is a performance cost associated with method
modifiers, but we have made every effort to make that cost directly
proportional to the number of modifier features you use.

The wrapping method does its best to <span class="synIdentifier">B&lt;only&gt;</span> do as much work as it
absolutely needs to. In order to do this we have moved some of the
performance costs to set-up time, where they are easier to amortize.

All this said, our benchmarks have indicated the following:

<span class="synPreProc">  simple wrapper with no modifiers             100% slower</span>
<span class="synPreProc">  simple wrapper with simple before modifier   400% slower</span>
<span class="synPreProc">  simple wrapper with simple after modifier    450% slower</span>
<span class="synPreProc">  simple wrapper with simple around modifier   500-550% slower</span>
<span class="synPreProc">  simple wrapper with all 3 modifiers          1100% slower</span>

These numbers may seem daunting, but you must remember, every feature
comes with some cost. To put things in perspective, just doing a
simple <span class="synIdentifier">C&lt;AUTOLOAD&gt;</span> which does nothing but extract the name of the
method called and return it costs about 400% over a normal method
call.

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_before_method_modifier($method_name, $code) &gt;&gt;</span>

This wraps the specified method with the supplied subroutine
reference. The modifier will be called as a method itself, and will
receive the same arguments as are passed to the method.

When the modifier exits, the wrapped method will be called.

The return value of the modifier will be ignored.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_after_method_modifier($method_name, $code) &gt;&gt;</span>

This wraps the specified method with the supplied subroutine
reference. The modifier will be called as a method itself, and will
receive the same arguments as are passed to the method.

When the wrapped methods exits, the modifier will be called.

The return value of the modifier will be ignored.

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_around_method_modifier($method_name, $code) &gt;&gt;</span>

This wraps the specified method with the supplied subroutine
reference.

The first argument passed to the modifier will be a subroutine
reference to the wrapped method. The second argument is the object,
and after that come any arguments passed when the method is called.

The around modifier can choose to call the original method, as well as
what arguments to pass if it does so.

The return value of the modifier is what will be seen by the caller.

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Introspection</span>

<span class="synStatement">=over</span> <span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;meta &gt;&gt;</span>

This will return a <span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span> instance for this class.

It should also be noted that <span class="synIdentifier">L&lt;Class::MOP&gt;</span> will actually bootstrap
this module by installing a number of attribute meta-objects into its
metaclass.

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

Moose is maintained by the Moose Cabal, along with the help of many contributors. See <span class="synIdentifier">L&lt;Moose/CABAL&gt;</span> and <span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span> for details.

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

This software is copyright (c) 2013 by Infinity Interactive, Inc..

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
